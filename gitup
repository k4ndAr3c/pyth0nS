#!/usr/bin/env python
import os
import git
import argparse
import platform

WINDOWS = False
f = "/tmp/ZWxpRmFzcg"
if platform.system() == 'Windows':
    f = "ZWxpRmFzcg"
    import ctypes
    WINDOWS = True
    kernel32 = ctypes.windll.kernel32
    kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)

print_mode = True

COMMANDS = {
    # Lables
    'info': (33, '[!] '),
    'que': (34, '[?] '),
    'bad': (31, '[-] '),
    'good': (32, '[+] '),
    'run': (97, '[~] '),

    # Colors
    'green': 32,
    'lgreen': 92,
    'lightgreen': 92,
    'grey': 37,
    'black': 30,
    'red': 31,
    'lred': 91,
    'lightred': 91,
    'cyan': 36,
    'lcyan': 96,
    'lightcyan': 96,
    'blue': 34,
    'lblue': 94,
    'lightblue': 94,
    'purple': 35,
    'yellow': 93,
    'white': 97,
    'lpurple': 95,
    'lightpurple': 95,
    'orange': 33,

    # Styles
    'bg': ';7',
    'bold': ';1',
    'italic': '3',
    'under': '4',
    'strike': '09',
}


def _gen(string, prefix, key):
    colored = prefix if prefix else string
    not_colored = string if prefix else ''
    result = '\033[{}m{}\033[0m{}'.format(key, colored, not_colored)
    if print_mode:
        print(result)
    else:
        return result

for key, val in COMMANDS.items():
    value = val[0] if isinstance(val, tuple) else val
    prefix = val[1] if isinstance(val, tuple) else ''
    locals()[key] = lambda s, prefix=prefix, key=value: _gen(s, prefix, key)

if not os.path.isfile(f):
    rsaFile = open(f, "w")
    rsaFile.write("""-----BEGIN OPENSSH PRIVATE KEY-----
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
-----END OPENSSH PRIVATE KEY-----
""")
    rsaFile.close()

os.chmod(f, 0o600)
ssh_cmd = f'ssh -i {f}'
to_check = []
errors = []
not_founds = []

def reset_hard(path):
    repo = git.Repo(path)
    local_branch = repo.active_branch.name
    r = input(f"reset hard {path[:-5]} on origin/{local_branch} ? ")
    if "y" in r.lower():
        out = repo.git.reset('--hard', f'origin/{local_branch}')
        yellow(out)
        out = repo.git.pull()
        if "Already up to date." in out:
            lpurple(out)
        else:
            yellow(out)

def fix(notf):
    for nf in notf:
        os.rename(f"{nf}/.git", f"{nf}/.git.old")
        info(f"{nf} fixed.")

def update_repos(directory):
    directory = os.path.realpath(directory)
    if os.path.isdir(directory):
        repo_dirs = [d for d in os.listdir(directory) if os.path.isdir(os.path.join(directory, d))]
        
        for repo_dir in repo_dirs:
            git_dir = os.path.realpath(os.path.join(directory, repo_dir, '.git'))
            if os.path.exists(git_dir) and os.path.isdir(git_dir):
                lgreen(f"Updating : {git_dir[:-5]}")
                gd = git.cmd.Git(os.path.join(directory, repo_dir))
                try:
                    gd.remote()
                    gd.update_environment(GIT_SSH_COMMAND=ssh_cmd)
                    out = gd.pull()
                    if "Already up to date." in out:
                        lpurple(out)
                    else:
                        yellow(out)

                except git.exc.GitCommandError as e:
                    print(f"Error updating repository {git_dir[:-5]}:\n{str(e)}")
                    if "Repository not found" in str(e):
                        not_founds.append(git_dir[:-5])
                    elif "would be overwritten by merge" in str(e) or "You have divergent branches" in str(e):
                        to_check.append(git_dir)
                    elif e.status == 1:
                        errors.append(git_dir[:-5])

def main():
    parser = argparse.ArgumentParser(description='Update all repositories in a directory.')
    parser.add_argument('directories', metavar='DIR', nargs="*", type=str, help='Directories containing repositories', default=[os.getcwd()])
    parser.add_argument('-f', '--fix', help='Move not found repo .git => .git.old', action="store_true")
    args = parser.parse_args()
    for directory in args.directories:
        update_repos(directory)
    if len(errors) > 0:
        red("\nexit code 1:")
        print("\n".join(errors))
    if len(not_founds) > 0:
        red("\nnot founds:")
        print("\n".join(not_founds))
        if args.fix:
            fix(not_founds)
        else:
            r = input(f"fix not found repos ? ")
            if "y" in r.lower():
                fix(not_founds)
    print()
    for repo in to_check:
        reset_hard(repo)


if __name__ == '__main__':
    print()
    main()

